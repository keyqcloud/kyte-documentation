<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">
    <meta property="og:locale" content="en_US">
    <meta property="og:type" content="website">
    <meta property="og:title" content="Kyte Documentation">
    <meta property="og:description" content="Learn how to create robust web apps with Kyte.">
    <title>Kyte Documentation</title>
    <style>
        pre {
            width: 100%;
            padding: 0;
            margin: 0;
            overflow: auto;
            overflow-y: hidden;
            font-size: 12px;
            line-height: 20px;
            background: #efefef;
            border: 1px solid #777;
            background: url(lines.png) repeat 0 0;
        }
        pre code {
            padding: 10px;
            color: #333;
        }
    </style>
</head>
<body>
    <h1>Kyte</h1>
    <small>version 3.x</small>

    <h2>1. Introduction</h2>

    <h3>1.1 Directory Structure</h3>
    <p>The directory structure of Kyte projects are simple. Configurations are found at the root (<code>/</code>) directory, while all other components (controllers and models) live in the <code>/app</code> directory.  Controllers are stored in <code>/app/controllers</code>, while models are stored in <code>/app/models</code>. To setup a workspace, simply create a folder for your project, and create the following folders inside: <code>/app/models</code> and <code>/app/controllers</code>. Next, create an <code>index.php</code> file at the root of your project folder and copy the following code:</p>
    
<pre><code>
&lt;?php

require __DIR__ . '/vendor/autoload.php';
require __DIR__ . '/config.php';

$app = new \Kyte\Core\Api();
$app->route();

?&gt; 
</code></pre>

    <p>Lastly, for all the magic to work, add the following <code>.htaccess</code> file also to the root of your project folder.</p>

<pre><code>
FallbackResource /index.php
</code></pre>

    <h3>1.2 Creating a model</h3>
    <p>By default, Kyte functions as an API out of the box, but isn't really useful until you customize it. The first step to customizing your API for your project is by definings the necessary models. Defining new models alone is sufficient for Kyte to function as it already has a default controller it uses to respond to and serve data, however this behaviour can also be modified using custom controllers (described later in this documentation).</p>
    <p>Models are simply a PHP array definition that is stored as source files in <code>/app/models</code> of your project. Separate files for each model definition must be created (you cannot have a file with multiple model definitions).</p>
    <p>Here's an example model that one might use to store device token information used for push notifications <code>/app/models/Device.php</code>.</p>
<pre><code>
// /app/models/Device.php
$Device = [
    'name' => 'Device',
    'struct' => [
        'token'		=> [
            'type'	=> 's',
            'required'	=> true,
            'date'	=> false,
            'size'	=> 512,
        ],
        'user'		=> [
            'type'		=> 'i',
            'required'	=> false,
            'date'	=> false,
            'size'	=> 11,
            'unsigned'	=> true,
            'fk'        => [
                'model' => 'User',
                'field' => 'id',
            ],
        ],
    ],
];
</code></pre>
    <p>In the example above, we see that we have a model named <code>Device</code> with two properties: <code>token</code> and <code>user</code>. The property <code>user</code> is defined as a string that cannot be made null (<code>'requred' => true</code>) and is 512 bytes long. You also see that the property is explicitly marked as not being a date (<code>'date' => false</code>). The date attribute is required for all property definitions in Kyte, and must be explicitly defined even for properties that are not dates.</p>
    <p>The next property that is defined in this example model is called <code>user</code>. This property is an unsigned integer of size 11, but this time the property can be set to null (<code>'required' => false</code>). You see the date attribute again explicitly defining the attribute as not being a date. Finally, the <code>fk</code> attribute indicates that this is a foreign key to a different model (table). Specifically, in this example, the <code>user</code> property is a foreign key to the <code>id</code> property of the <code>User</code> model.</p>
    <p>Model definitions will always take the format shown below, where the Array variable name is the name of the model, containing <code>name</code> and <code>struct</code> elements.</p>
<pre><code>
$ModelName = [
    'name' => 'ModelName',
    'struct' => [
        /* property definition */
    ],
];
</code></pre>
    <p>The <code>struct</code> element holds the property definitions, like the ones we saw earlier in the <code>Device</code> model example. Let's next take a look at the different property types that can be defined in Kyte.</p>

    <h4>1.2.1 Integers</h4>
<pre><code>
'{propertyName}'	=> [
    'type'	=> 'i',
    'date'	=> false,
    'required'	=> {true/false},
    'size'	=> {size},
    'unsigned'	=> {true/false},
],
</code></pre>

    <h4>1.2.2 Strings</h4>
<pre><code>
'{propertyName}'	=> [
    'type'	=> 's',
    'date'	=> false,
    'required'	=> {true/false},
    'size'	=> {size},
]
</code></pre>

    <h4>1.2.3 Decimals</h4>
<pre><code>
'{propertyName}'	=> [
    'type'  => 'd',
    'date'  => false,
    'required'  => {true/false},
    'precision' => {precision},
    'scale' => {scale},
]
</code></pre>
<p>For decimals, specify <code>'d'</code> for <code>type</code> and indicate the required precision and scale that you need. Precision is the total number of digits, while scale is the number of digits right of the decimal point. For example, the decimal number 12345.67 has a precision of 7 digits, and a scale of 2 digits.</p>

    <h4>1.2.4 Text</h4>
<pre><code>
'{propertyName}'	=> [
    'type'	=> 't',
    'date'	=> false,
    'required'	=> {true/false},
]
</code></pre>
    
    <h4>1.2.5 Dates</h4>
<pre><code>
'{propertyName}'	=> [
    'type'	=> 'i',
    'date'	=> true,
    'required'	=> {true/false},
]
</code></pre>
<p>Dates use <code>'i'</code> for <code>type</code> as the date is stored as UNIX time in secods as a long integer.</p>

    <h4>1.2.6 Foreign Keys</h4>
<pre><code>
'{propertyName}'	=> [
    'type'	=> 'i',
    'date'	=> false,
    'size'	=> 11,
    'unsigned'	=> true,
    'required'	=> {true/false},
    'fk'        => [
        'model' => '{modelName}',
        'field' => '{propertyName}',
    ],
]
</code></pre>

<h4>1.2.7 Protected Flag</h4>
<pre><code>
'{propertyName}'	=> [
    'type'	=> 's',
    'date'	=> false,
    'protected'	=> true,
    'required'	=> {true/false},
    'size'	=> {size},
]
</code></pre>
<p>When a protected flag is present for a property, the value of that property is not returned by the controller unless the behaviour is customized with hooks or overrides. You may want to use this for properties that store sensitive information that should not be returned to the user, such as password hashes.</p>

<h4>1.2.8 Encrypted Flag (beta)</h4>
<pre><code>
'{propertyName}'	=> [
    'type'	=> 's',
    'date'	=> false,
    'encrypted'	=> true,
    'required'	=> {true/false},
    'size'	=> 255, // minimally recommended for storing cipher
]
</code></pre>
<p>The encrypted flag marks the property as needing encryption with AWS's KMS encryption services. The property value will be encrypted using a KMS key specified in the configuration and the cipher stored in the dabatase.</p>

<h3>1.3 Controllers</h3>
<p>As mentioned earlier, model definitions are sufficient for Kyte to function as a default controller called <code>ModelController</code> handles all requests. By default, the <code>ModelController</code> handles GET, POST, PUT, and DELETE calls for authenticated users.  However, the default controller behaviour at times may not be sufficient for your application and thus can be customized. There are two different ways to customize controller behaviour in Kyte: (1) using hooks, (2) defining a custom controller. For most use cases, the first option will provide plenty of flexibility. However, option 2 may be necessary when you require more complicated customizations or the use of virtual controllers (explained later in this documentation).</p>
<p>Let's start by exploring the default behaviour.</p>

<h4>1.3.1 Default Behaviour</h4>
<p>The default controller behaviour requires users to be authenticated and have the necessary permissions (we'll discuss how to communicate with your API and create sessions later). When a request is made to a Kyte endpoint, the request is first validated (more details later). Once a request had been validated, the request type (GET, POST, PUT, DELETE) and any associated parameters and body data are parsed before handing off to the controller. The controller will then make the appropriate transaction and return the results back to the user.</p>

<h4>1.3.2 Controller Customization (using hooks)</h4>

<h4>1.3.3 Custom Controllers</h4>

<h4>1.3.4 Virtual Controllers</h4>

    <hr />
    
    <small>&copy; KeyQ, Inc.</small>
</body>
</html>
